<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ear Training App</title>
    <!-- Use the Inter font for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Include Tailwind CSS via CDN for rapid styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">

    <!-- Main application container -->
    <div id="app-container" class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-lg text-center flex flex-col items-center">

        <!-- App title and description -->
        <h1 class="text-3xl sm:text-4xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">Ear Trainer</h1>
        <p id="curriculum-status" class="text-gray-400 text-sm sm:text-base mb-6">Curriculum: Major Scale</p>

        <!-- Play button -->
        <button id="play-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 active:scale-95 shadow-md">
            <svg class="h-6 w-6 inline-block mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
            </svg>
            Play Interval
        </button>

        <!-- Message and score container - SIMPLIFIED -->
        <div id="message-container" class="mt-6 w-full">
            <p id="message" class="text-lg font-semibold text-gray-300 h-6"></p>
            <p class="text-sm text-gray-500 mt-2">
                <span class="font-semibold">Total Correct:</span> 
                <span id="score-counter">0</span> 
            </p>
        </div>

        <!-- Answer choices grid -->
        <div id="choices-container" class="grid grid-cols-2 gap-4 mt-6 w-full">
            <!-- Buttons will be dynamically added here -->
        </div>
        
        <!-- Stats and Reset Button -->
        <div class="mt-8">
             <button id="reset-stats-button" class="text-xs text-red-400 hover:text-red-500 transition duration-150">Reset All Stats (Progress Cleared)</button>
        </div>

    </div>

    <!-- Tone.js for audio generation -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

    <script>
        // Use a self-invoking anonymous function to keep variables out of the global scope
        (function() {
            // --- UI Elements ---
            const playButton = document.getElementById('play-button');
            const choicesContainer = document.getElementById('choices-container');
            const messageEl = document.getElementById('message');
            const scoreCounterEl = document.getElementById('score-counter');
            const resetStatsButton = document.getElementById('reset-stats-button');
            const curriculumStatusEl = document.getElementById('curriculum-status'); 

            // --- Constants and State Variables ---
            const STARTING_MIDI_MIN = 48; // C3
            const STARTING_MIDI_MAX = 72; // C5
            const STATS_STORAGE_KEY = 'earTrainingConfusionMatrixV2'; // Changed key for new tracking format
            const MAJOR_SCALE_CORRECTNESS_THRESHOLD = 2; 
            const WRONG_ANSWER_COUNT = 3;

            // Matrix sizes: Rows for the 25 directed possibilities, Columns for the 13 possible user guesses (semitones 0-12)
            const STATS_MATRIX_SIZE_PLAYED = 25; // 0 (Unison), 1-12 (Asc), 13-24 (Desc)
            const STATS_MATRIX_SIZE_GUESSED = 13; // 0-12 semitones

            let synth = null;
            let currentCorrectInterval; // Holds the full directed interval object for the current question
            let currentStartNote;     
            let currentIntervalShift; // The actual semitone shift (+ve or -ve)

            // The 25x13 matrix where index [i][j] tracks: 
            // Played Directed Index 'i' (0-24), User Guessed Semitones 'j' (0-12).
            let earTrainingStats = []; 

            // --- Game Data ---

            // Base intervals (used for UI buttons)
            const intervals = [
                { name: "Unison", semitones: 0 },
                { name: "Minor 2nd", semitones: 1 },
                { name: "Major 2nd", semitones: 2 },
                { name: "Minor 3rd", semitones: 3 },
                { name: "Major 3rd", semitones: 4 },
                { name: "Perfect 4th", semitones: 5 },
                { name: "Tritone", semitones: 6 },
                { name: "Perfect 5th", semitones: 7 },
                { name: "Minor 6th", semitones: 8 },
                { name: "Major 6th", semitones: 9 },
                { name: "Minor 7th", semitones: 10 },
                { name: "Major 7th", semitones: 11 },
                { name: "Octave", semitones: 12 }
            ];

            // Generates a list of all 25 directed intervals for internal tracking and question selection
            const directedIntervals = (() => {
                const directed = [];
                const chromaticIntervals = intervals.filter(i => i.semitones >= 0);

                chromaticIntervals.forEach(interval => {
                    const { name, semitones } = interval;

                    // Unison (semitones 0)
                    if (semitones === 0) {
                        directed.push({
                            name: name,
                            semitones: semitones,
                            direction: 'N/A',
                            playedIndex: 0
                        });
                        return;
                    }

                    // Ascending (Index 1 to 12)
                    directed.push({
                        name: name,
                        semitones: semitones,
                        direction: 'Ascending',
                        playedIndex: semitones
                    });

                    // Descending (Index 13 to 24)
                    directed.push({
                        name: name,
                        semitones: semitones,
                        direction: 'Descending',
                        playedIndex: semitones + 12
                    });
                });
                return directed;
            })();

            // Define major scale intervals for curriculum logic (now as directed intervals)
            const majorScaleSemitones = [0, 2, 4, 5, 7, 9, 11, 12];
            const majorScaleDirectedIntervals = directedIntervals.filter(int => 
                majorScaleSemitones.includes(int.semitones)
            );
            
            // Base intervals used for UI *when restricted* (Unison, M2, M3, P4, P5, M6, M7, Octave)
            const majorScaleIntervalsUI = intervals.filter(int => 
                majorScaleSemitones.includes(int.semitones)
            );
            
            // --- Utility Functions ---

            // Helper to get the semitones (0-12) from a played index (0-24)
            function getSemitonesFromPlayedIndex(playedIndex) {
                if (playedIndex === 0) return 0;
                // Indices 1-12 (Ascending) -> semitones 1-12
                // Indices 13-24 (Descending) -> semitones 1-12
                return playedIndex <= 12 ? playedIndex : playedIndex - 12;
            }

            // Fisher-Yates shuffle algorithm to randomize an array
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Function to generate a random number within a range (inclusive)
            function getRandomNumber(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // --- Stats Persistence Logic ---

            // Creates a fresh 25x13 array filled with zeros
            function initializeStatsMatrix() {
                const matrix = [];
                for (let i = 0; i < STATS_MATRIX_SIZE_PLAYED; i++) {
                    matrix[i] = new Array(STATS_MATRIX_SIZE_GUESSED).fill(0);
                }
                return matrix;
            }

            /**
             * Loads stats from localStorage, or initializes if missing/corrupt.
             */
            function loadStats() {
                try {
                    const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                    if (storedStats) {
                        earTrainingStats = JSON.parse(storedStats);
                        // Integrity check: ensure it's the correct 25x13 structure
                        if (earTrainingStats.length !== STATS_MATRIX_SIZE_PLAYED || 
                            (earTrainingStats.length > 0 && earTrainingStats[0].length !== STATS_MATRIX_SIZE_GUESSED)) {
                            console.warn("Stored stats matrix structure mismatch (V2 check failed). Re-initializing.");
                            earTrainingStats = initializeStatsMatrix();
                        }
                    } else {
                        // Initialize only if no stored data is found.
                        earTrainingStats = initializeStatsMatrix();
                    }
                } catch (e) {
                    console.error("Error loading stats from localStorage:", e);
                    // Fallback to fresh matrix on error
                    earTrainingStats = initializeStatsMatrix(); 
                }
            }

            // Saves current stats to localStorage
            function saveStats() {
                try {
                    localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(earTrainingStats));
                } catch (e) {
                    console.error("Error saving stats to localStorage:", e);
                }
            }

            /**
             * Calculates the Correctness Score (Correct - Incorrect * 2) for a specific directed interval.
             * @param {number} playedIndex - The internal index (0-24) representing the directed interval.
             * @returns {number} The correctness score.
             */
            function getCorrectnessScore(playedIndex) {
                if (!earTrainingStats[playedIndex]) return 0;
                
                const correctSemitones = getSemitonesFromPlayedIndex(playedIndex);
                
                let correctCount = earTrainingStats[playedIndex][correctSemitones];
                let totalAttemptsForInterval = earTrainingStats[playedIndex].reduce((a, b) => a + b, 0);
                let incorrectCount = totalAttemptsForInterval - correctCount;
                
                // Incorrect answers are multiplied by 2 (Lower Penalty)
                return correctCount - (incorrectCount * 2);
            }

            // Calculates the simple total number of correct answers (for UI display)
            function calculateTotalCorrectAnswers(availableDirectedIntervals) {
                let totalCorrect = 0;
                // Iterate over all available directed intervals in the current set
                availableDirectedIntervals.forEach(directedInterval => {
                    const playedIndex = directedInterval.playedIndex;
                    const correctSemitones = directedInterval.semitones;

                    // Correct count is stored where the played interval (row index) equals the correct semitone (column index)
                    if (earTrainingStats[playedIndex] && earTrainingStats[playedIndex][correctSemitones] !== undefined) {
                        totalCorrect += earTrainingStats[playedIndex][correctSemitones];
                    }
                });
                return totalCorrect;
            }

            // Updates the UI counters based on the current curriculum and stats matrix
            function updateScoreDisplay(availableDirectedIntervals) {
                const totalCorrect = calculateTotalCorrectAnswers(availableDirectedIntervals);
                scoreCounterEl.textContent = totalCorrect;
            }

            // Clears all stats and resets the matrix
            function resetStats() {
                localStorage.removeItem(STATS_STORAGE_KEY);
                earTrainingStats = initializeStatsMatrix();
                console.log("All Ear Training Stats have been reset.");
                
                // Update UI state
                messageEl.textContent = "Stats Reset! Progress cleared.";
                messageEl.classList.remove('text-green-500', 'text-red-500', 'text-gray-300');
                messageEl.classList.add('text-yellow-500');
                
                // Update display to reflect zero score
                updateScoreDisplay(majorScaleDirectedIntervals);

                // Start a new question
                setTimeout(generateQuestion, 500); 
            }
            
            // --- Curriculum Logic ---

            // Determines if the training should be restricted to major scale directed intervals
            function shouldRestrictToMajorScale() {
                // Check if *any* directed major scale interval has a score below the threshold.
                for (const directedInterval of majorScaleDirectedIntervals) {
                    const score = getCorrectnessScore(directedInterval.playedIndex);
                    if (score < MAJOR_SCALE_CORRECTNESS_THRESHOLD) {
                        return true; // Still restricted to major scale
                    }
                }
                return false; // All major scale intervals passed the threshold, unlock full chromatic
            }

            // --- Smart Question Selection Logic ---

            /**
             * Chooses the next directed interval based on a weighted random choice where lower correctness scores have higher probability.
             * @param {Array} directedIntervalSet - The set of directed intervals (0-24) to choose from.
             * @returns {Object} The chosen directed interval object.
             */
            function chooseNextInterval(directedIntervalSet) {
                const intervalData = [];
                let maxScore = -Infinity;
                let totalAttemptsInSet = 0;

                // 1. Calculate scores and find maxScore
                for (const directedInterval of directedIntervalSet) {
                    const playedIndex = directedInterval.playedIndex;
                    
                    let totalAttemptsForInterval = earTrainingStats[playedIndex].reduce((a, b) => a + b, 0);
                    totalAttemptsInSet += totalAttemptsForInterval;

                    let score = getCorrectnessScore(playedIndex);
                    
                    intervalData.push({
                        directedInterval: directedInterval,
                        score: score
                    });

                    if (score > maxScore) {
                        maxScore = score;
                    }
                }
                
                // If there are no attempts at all, revert to pure random selection from the set
                if (totalAttemptsInSet === 0) {
                    return directedIntervalSet[getRandomNumber(0, directedIntervalSet.length - 1)];
                }

                // 2. Calculate weights (Weight = maxScore - currentScore + 1)
                let totalWeight = 0;
                intervalData.forEach(data => {
                    // Weight is always >= 1 (even the best-performing interval has a weight of 1)
                    data.weight = maxScore - data.score + 1;
                    totalWeight += data.weight;
                });
                
                // 3. Perform weighted random selection
                let randomValue = Math.random() * totalWeight;

                for (const data of intervalData) {
                    randomValue -= data.weight;
                    if (randomValue <= 0) {
                        return data.directedInterval;
                    }
                }
                
                // Fallback (should not be hit if logic is correct)
                return directedIntervalSet[directedIntervalSet.length - 1];
            }

            // --- Audio & Game Logic ---

            // Plays the interval notes using the stored state
            async function playInterval() {
                // Ensure Tone.js is running, which requires a user gesture.
                await Tone.start();

                // Initialize the synth only once, after Tone.js is ready.
                if (!synth) {
                    // Using a slightly more complex waveform for better ear recognition
                    synth = new Tone.Synth({
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                }

                messageEl.textContent = "Listen...";
                
                // Use the parameters calculated and stored in generateQuestion()
                const startNote = currentStartNote;
                const intervalShift = currentIntervalShift;

                // Calculate the second note using Tone.Frequency.transpose()
                const endNote = Tone.Frequency(startNote).transpose(intervalShift).toNote();

                // Play the notes sequentially
                synth.triggerAttackRelease(startNote, "8n");
                // Note 2 is scheduled after 800ms
                setTimeout(() => {
                    synth.triggerAttackRelease(endNote, "8n");
                }, 800);
            }

            // Generates a new question, including the randomization of the interval to be played
            function generateQuestion() {
                messageEl.textContent = "";
                choicesContainer.innerHTML = "";
                
                // Determine the available pool of directed intervals based on curriculum status
                const restrict = shouldRestrictToMajorScale();
                const availableDirectedIntervals = restrict ? majorScaleDirectedIntervals : directedIntervals;
                
                // *** FIX: Determine the pool of UI choices (buttons) based on restriction ***
                const availableUIIntervals = restrict ? majorScaleIntervalsUI : intervals;
                
                // Update the curriculum status message
                if (restrict) {
                    curriculumStatusEl.textContent = "Curriculum: Major Scale (Focusing on M2, M3, P4, P5, M6, M7)";
                } else {
                    curriculumStatusEl.textContent = "Curriculum: Full Chromatic Scale (All Intervals Unlocked)";
                }

                // Update the score display based on the current curriculum selection
                updateScoreDisplay(availableDirectedIntervals);

                // 1. Select the correct directed interval type using the smart logic
                currentCorrectInterval = chooseNextInterval(availableDirectedIntervals);
                const correctPlayedIndex = currentCorrectInterval.playedIndex;
                const correctSemitones = currentCorrectInterval.semitones;

                // 2. Determine the random starting note and the actual shift (+/- semitones)
                const startMidi = getRandomNumber(STARTING_MIDI_MIN, STARTING_MIDI_MAX);
                currentStartNote = Tone.Midi(startMidi).toNote();
                
                // Calculate the actual shift: positive for Ascending (Index 1-12), negative for Descending (Index 13-24)
                if (correctPlayedIndex === 0) {
                    // Unison
                    currentIntervalShift = 0;
                } else if (correctPlayedIndex <= 12) {
                    // Ascending (Index 1-12)
                    currentIntervalShift = correctSemitones;
                } else {
                    // Descending (Index 13-24)
                    currentIntervalShift = -correctSemitones;
                }

                // --- 3. Weighted selection for incorrect answer choices ---
                
                // Potential pool of wrong answers based on the AVAILABLE UI intervals
                const potentialWrongIntervals = availableUIIntervals.filter(interval => interval.semitones !== correctSemitones);

                let weightedWrongChoices = [];
                let totalConfusionWeight = 0;

                potentialWrongIntervals.forEach(interval => {
                    // Weight is the number of times the user confused the correct directed interval (correctPlayedIndex)
                    // with this wrong semitone interval (interval.semitones).
                    const confusionCount = earTrainingStats[correctPlayedIndex][interval.semitones];
                    
                    // Add a base weight of 1 to ensure even rarely confused choices have a chance
                    const weight = confusionCount + 1; 

                    weightedWrongChoices.push({
                        interval: interval,
                        weight: weight
                    });
                    totalConfusionWeight += weight;
                });
                
                // Select unique wrong answers using weighted random sampling
                let selectedWrongAnswers = [];
                let availableWrongChoices = [...weightedWrongChoices]; 

                const wrongAnswerCountToPick = Math.min(WRONG_ANSWER_COUNT, availableWrongChoices.length);

                while (selectedWrongAnswers.length < wrongAnswerCountToPick && availableWrongChoices.length > 0) {
                    let randomValue = Math.random() * totalConfusionWeight;
                    
                    for (let i = 0; i < availableWrongChoices.length; i++) {
                        const choice = availableWrongChoices[i];
                        
                        randomValue -= choice.weight;
                        
                        if (randomValue <= 0) {
                            // Found a selected wrong answer
                            selectedWrongAnswers.push(choice.interval);
                            
                            // Remove the selected choice from the pool and update total weight
                            totalConfusionWeight -= choice.weight;
                            availableWrongChoices.splice(i, 1);
                            break; 
                        }
                    }
                }
                // --- End of weighted selection ---

                // 4. Combine and shuffle the choices for the buttons 
                const choices = shuffleArray([
                    // Use the availableUIIntervals list to find the correct choice object
                    availableUIIntervals.find(i => i.semitones === correctSemitones), 
                    ...selectedWrongAnswers
                ]);

                // 5. Create and append the choice buttons
                choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.textContent = choice.name;
                    button.classList.add('choice-button', 'bg-gray-700', 'hover:bg-gray-600', 'text-white', 'font-semibold', 'py-3', 'rounded-xl', 'transition', 'duration-200', 'active:scale-95');
                    button.onclick = () => handleAnswer(choice);
                    choicesContainer.appendChild(button);
                });

                // Re-enable the play button
                playButton.disabled = false;
                playButton.classList.remove('opacity-50', 'cursor-not-allowed');

                // *** AUTOPLAY THE INTERVAL ***
                playInterval();
            }

            // Handles the user's answer choice
            function handleAnswer(selectedChoice) {
                
                // --- Record Keeping Update ---
                const correctPlayedIndex = currentCorrectInterval.playedIndex; // Row index (0-24)
                const correctSemitones = currentCorrectInterval.semitones;
                const guessedSemitones = selectedChoice.semitones;         // Column index (0-12)
                
                let statsUpdated = false;
                
                // 1. Record the actual attempt (Played Directed Interval, User Guessed Semitone).
                if (correctPlayedIndex >= 0 && correctPlayedIndex < STATS_MATRIX_SIZE_PLAYED && 
                    guessedSemitones >= 0 && guessedSemitones < STATS_MATRIX_SIZE_GUESSED) {
                    
                    earTrainingStats[correctPlayedIndex][guessedSemitones]++;
                    statsUpdated = true;
                } else {
                    console.error("Invalid semitone indices encountered in handleAnswer.");
                }

                // --- UI and Scoring Logic ---
                
                // Disable all choice buttons to prevent multiple clicks
                const allButtons = document.querySelectorAll('.choice-button');
                allButtons.forEach(btn => btn.disabled = true);
                
                if (guessedSemitones === correctSemitones) {
                    messageEl.textContent = "Correct!";
                    messageEl.classList.remove('text-red-500', 'text-yellow-500', 'text-gray-300');
                    messageEl.classList.add('text-green-500');
                } else {
                    // This message now includes the name, but not the direction, as per the original requirement.
                    messageEl.textContent = `Incorrect. The answer was a ${currentCorrectInterval.name}.`;
                    messageEl.classList.remove('text-green-500', 'text-yellow-500', 'text-gray-300');
                    messageEl.classList.add('text-red-500');

                    // NOTE: Symmetric confusion tracking is more complex with directed intervals (V3), 
                    // so for V2 we only track the specific confusion from played directed interval to guessed semitone.
                }

                // 2. Save stats once if any update occurred
                if (statsUpdated) {
                    saveStats();
                }

                // Recalculate and update score display based on the updated matrix
                const restrict = shouldRestrictToMajorScale();
                const availableDirectedIntervals = restrict ? majorScaleDirectedIntervals : directedIntervals;
                updateScoreDisplay(availableDirectedIntervals);

                // Disable play button while waiting
                playButton.disabled = true;
                playButton.classList.add('opacity-50', 'cursor-not-allowed');

                // Wait a moment before generating a new question
                setTimeout(() => {
                    generateQuestion();
                }, 2000); // 2-second delay
            }

            // --- Event Listeners and Initialization ---
            
            // Play button listener
            playButton.addEventListener('click', playInterval);

            // Reset stats button listener
            resetStatsButton.addEventListener('click', resetStats);

            // Start the application when the DOM is fully loaded
            document.addEventListener('DOMContentLoaded', () => {
                loadStats(); // Load existing or initialize new stats matrix
                
                // Initial score update based on loaded data
                const restrict = shouldRestrictToMajorScale();
                const availableDirectedIntervals = restrict ? majorScaleDirectedIntervals : directedIntervals;
                updateScoreDisplay(availableDirectedIntervals);
                
                // Generate question will now trigger the sound automatically
                generateQuestion();
            });

        })();
    </script>
</body>
</html>
