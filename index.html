<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ear Training App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Include Tailwind CSS via CDN for rapid styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
        }
        /* Custom scrollbar for the settings panel if needed */
        #settings-panel {
            scrollbar-width: thin;
            scrollbar-color: #4B5563 #1F2937;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">

    <!-- Main application container -->
    <div id="app-container" class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-lg text-center flex flex-col items-center">

        <!-- App title and description -->
        <h1 class="text-3xl sm:text-4xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">Ear Trainer</h1>

        <!-- Interval Selector (Collapsible) -->
        <div class="w-full mb-6 border-b border-gray-700 pb-4">
            <button id="toggle-settings-btn" class="text-sm text-gray-400 hover:text-white flex items-center justify-center w-full focus:outline-none transition-colors duration-200 py-2">
                <span class="font-semibold tracking-wide">⚙️ SELECT INTERVALS</span>
                <svg id="settings-arrow" class="w-4 h-4 ml-1 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            
            <div id="settings-panel" class="hidden bg-gray-900/50 rounded-xl p-4 text-left mt-2 border border-gray-700">
                <div class="flex justify-between mb-3 items-center border-b border-gray-700 pb-2">
                    <span class="text-xs text-gray-400 uppercase font-bold">Focus</span>
                    <div class="space-x-2">
                        <button id="select-all-btn" class="text-xs bg-blue-900 hover:bg-blue-800 text-blue-200 px-2 py-1 rounded transition">All</button>
                        <button id="select-none-btn" class="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 px-2 py-1 rounded transition">None</button>
                    </div>
                </div>
                <div id="interval-checkboxes" class="grid grid-cols-2 gap-y-2 gap-x-4 text-sm text-gray-300">
                    <!-- Checkboxes will be dynamically added here -->
                </div>
            </div>
        </div>

        <!-- Play button -->
        <button id="play-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 active:scale-95 shadow-md">
            <svg class="h-6 w-6 inline-block mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
            </svg>
            Play Interval
        </button>

        <!-- Message and score container -->
        <div id="message-container" class="mt-6 w-full">
            <p id="message" class="text-lg font-semibold text-gray-300 min-h-[1.5rem]"></p>
            <p class="text-sm text-gray-500 mt-2">
                <span class="font-semibold">Total Correct:</span> 
                <span id="score-counter">0</span> 
            </p>
        </div>

        <!-- Answer choices grid -->
        <div id="choices-container" class="grid grid-cols-2 gap-4 mt-6 w-full">
            <!-- Buttons will be dynamically added here -->
        </div>
        
        <!-- Stats and Reset Button -->
        <div class="mt-8">
             <button id="reset-stats-button" class="text-xs text-red-400 hover:text-red-500 transition duration-150">Reset All Stats (Progress Cleared)</button>
        </div>

    </div>

    <!-- Tone.js for audio generation -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

    <script>
        // Use a self-invoking anonymous function to keep variables out of the global scope
        (function() {
            // --- UI Elements ---
            const playButton = document.getElementById('play-button');
            const choicesContainer = document.getElementById('choices-container');
            const messageEl = document.getElementById('message');
            const scoreCounterEl = document.getElementById('score-counter');
            const resetStatsButton = document.getElementById('reset-stats-button');
            
            // Settings UI Elements
            const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
            const settingsPanel = document.getElementById('settings-panel');
            const settingsArrow = document.getElementById('settings-arrow');
            const selectAllBtn = document.getElementById('select-all-btn');
            const selectNoneBtn = document.getElementById('select-none-btn');
            const checkboxesContainer = document.getElementById('interval-checkboxes');

            // --- Constants and State Variables ---
            const STARTING_MIDI_MIN = 48; // C3
            const STARTING_MIDI_MAX = 72; // C5
            const STATS_STORAGE_KEY = 'earTrainingConfusionMatrixV2'; 
            const MAJOR_SCALE_CORRECTNESS_THRESHOLD = 2; 
            const WRONG_ANSWER_COUNT = 3;

            // Matrix sizes: Rows for the 25 directed possibilities, Columns for the 13 possible user guesses
            const STATS_MATRIX_SIZE_PLAYED = 25; // 0 (Unison), 1-12 (Asc), 13-24 (Desc)
            const STATS_MATRIX_SIZE_GUESSED = 13; // 0-12 semitones

            let synth = null;
            let currentCorrectInterval; 
            let currentStartNote;     
            let currentIntervalShift; 
            let currentChoices = []; // Tracks the currently displayed answer choices

            let earTrainingStats = []; 
            
            // --- Game Data ---

            const intervals = [
                { name: "Unison", semitones: 0 },
                { name: "Minor 2nd", semitones: 1 },
                { name: "Major 2nd", semitones: 2 },
                { name: "Minor 3rd", semitones: 3 },
                { name: "Major 3rd", semitones: 4 },
                { name: "Perfect 4th", semitones: 5 },
                { name: "Tritone", semitones: 6 },
                { name: "Perfect 5th", semitones: 7 },
                { name: "Minor 6th", semitones: 8 },
                { name: "Major 6th", semitones: 9 },
                { name: "Minor 7th", semitones: 10 },
                { name: "Major 7th", semitones: 11 },
                { name: "Octave", semitones: 12 }
            ];

            // --- URL State Management ---

            function getIntervalsFromURL() {
                const params = new URLSearchParams(window.location.search);
                const intervalsParam = params.get('intervals');
                const selected = new Set();

                if (intervalsParam !== null) {
                    if (intervalsParam.trim() === '') return selected;
                    const parts = intervalsParam.split('-');
                    parts.forEach(p => {
                        const val = parseInt(p);
                        if (!isNaN(val) && val >= 0 && val <= 12) {
                            selected.add(val);
                        }
                    });
                } else {
                    intervals.forEach(i => selected.add(i.semitones));
                }
                return selected;
            }

            function updateURLFromSelection() {
                const sorted = Array.from(userSelectedSemitones).sort((a, b) => a - b);
                const params = new URLSearchParams(window.location.search);
                
                if (sorted.length === intervals.length) {
                    params.delete('intervals');
                } else {
                    params.set('intervals', sorted.join('-'));
                }
                
                const newQuery = params.toString();
                const newUrl = window.location.pathname + (newQuery ? '?' + newQuery : '');
                window.history.replaceState(null, '', newUrl);
            }

            // Initialize userSelectedSemitones from URL on load
            let userSelectedSemitones = getIntervalsFromURL(); 

            const directedIntervals = (() => {
                const directed = [];
                const chromaticIntervals = intervals.filter(i => i.semitones >= 0);

                chromaticIntervals.forEach(interval => {
                    const { name, semitones } = interval;
                    if (semitones === 0) {
                        directed.push({ name, semitones, direction: 'N/A', playedIndex: 0 });
                        return;
                    }
                    directed.push({ name, semitones, direction: 'Ascending', playedIndex: semitones });
                    directed.push({ name, semitones, direction: 'Descending', playedIndex: semitones + 12 });
                });
                return directed;
            })();

            const majorScaleSemitones = [0, 2, 4, 5, 7, 9, 11, 12];
            const majorScaleDirectedIntervals = directedIntervals.filter(int => 
                majorScaleSemitones.includes(int.semitones)
            );
            
            const majorScaleIntervalsUI = intervals.filter(int => 
                majorScaleSemitones.includes(int.semitones)
            );
            
            // --- Utility Functions ---

            function getSemitonesFromPlayedIndex(playedIndex) {
                if (playedIndex === 0) return 0;
                return playedIndex <= 12 ? playedIndex : playedIndex - 12;
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function getRandomNumber(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            /**
             * Checks if the currently displayed question (correct answer + choices) 
             * is valid under the current set of userSelectedSemitones.
             */
            function isCurrentQuestionValid() {
                // No question active yet
                if (!currentCorrectInterval || currentChoices.length === 0) return false;

                // 1. Check if the correct answer is still in selected semitones
                if (!userSelectedSemitones.has(currentCorrectInterval.semitones)) return false;

                // 2. Check if ALL displayed choices are still in selected semitones
                for (const choice of currentChoices) {
                    if (!userSelectedSemitones.has(choice.semitones)) {
                        return false;
                    }
                }

                return true;
            }

            // --- Settings / Checkbox UI Functions ---

            function renderIntervalCheckboxes() {
                checkboxesContainer.innerHTML = '';
                intervals.forEach(interval => {
                    const wrapper = document.createElement('label');
                    wrapper.className = 'flex items-center space-x-2 cursor-pointer hover:text-white transition';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = interval.semitones;
                    checkbox.checked = userSelectedSemitones.has(interval.semitones);
                    checkbox.className = 'form-checkbox h-4 w-4 text-blue-600 rounded border-gray-600 bg-gray-700 focus:ring-blue-500 focus:ring-offset-gray-800';
                    
                    // Event listener for individual checkbox
                    checkbox.addEventListener('change', (e) => {
                        const semitone = parseInt(e.target.value);
                        if (e.target.checked) {
                            userSelectedSemitones.add(semitone);
                        } else {
                            userSelectedSemitones.delete(semitone);
                        }
                        updateURLFromSelection(); 
                        
                        // Only regenerate if the current question is now invalid.
                        // Do NOT play sound on settings change (pass false).
                        if (!isCurrentQuestionValid()) {
                            generateQuestion(false); 
                        }
                    });

                    const text = document.createElement('span');
                    text.textContent = interval.name;

                    wrapper.appendChild(checkbox);
                    wrapper.appendChild(text);
                    checkboxesContainer.appendChild(wrapper);
                });
            }

            function toggleSettingsPanel() {
                const isHidden = settingsPanel.classList.contains('hidden');
                if (isHidden) {
                    settingsPanel.classList.remove('hidden');
                    settingsArrow.classList.add('rotate-180');
                } else {
                    settingsPanel.classList.add('hidden');
                    settingsArrow.classList.remove('rotate-180');
                }
            }

            function selectAllIntervals() {
                intervals.forEach(i => userSelectedSemitones.add(i.semitones));
                updateURLFromSelection(); 
                renderIntervalCheckboxes(); 
                // Usually "All" includes the current subset, so it shouldn't invalidate.
                // But we check just in case.
                if (!isCurrentQuestionValid()) {
                    generateQuestion(false);
                }
            }

            function selectNoneIntervals() {
                userSelectedSemitones.clear();
                updateURLFromSelection(); 
                renderIntervalCheckboxes();
                // This will definitely invalidate the question.
                generateQuestion(false);
            }

            // --- Stats Persistence Logic ---

            function initializeStatsMatrix() {
                const matrix = [];
                for (let i = 0; i < STATS_MATRIX_SIZE_PLAYED; i++) {
                    matrix[i] = new Array(STATS_MATRIX_SIZE_GUESSED).fill(0);
                }
                return matrix;
            }

            function loadStats() {
                try {
                    const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                    if (storedStats) {
                        earTrainingStats = JSON.parse(storedStats);
                        if (earTrainingStats.length !== STATS_MATRIX_SIZE_PLAYED || 
                            (earTrainingStats.length > 0 && earTrainingStats[0].length !== STATS_MATRIX_SIZE_GUESSED)) {
                            earTrainingStats = initializeStatsMatrix();
                        }
                    } else {
                        earTrainingStats = initializeStatsMatrix();
                    }
                } catch (e) {
                    earTrainingStats = initializeStatsMatrix(); 
                }
            }

            function saveStats() {
                try {
                    localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(earTrainingStats));
                } catch (e) {
                    console.error("Error saving stats to localStorage:", e);
                }
            }

            function getCorrectnessScore(playedIndex) {
                if (!earTrainingStats[playedIndex]) return 0;
                const correctSemitones = getSemitonesFromPlayedIndex(playedIndex);
                let correctCount = earTrainingStats[playedIndex][correctSemitones];
                let totalAttemptsForInterval = earTrainingStats[playedIndex].reduce((a, b) => a + b, 0);
                let incorrectCount = totalAttemptsForInterval - correctCount;
                return correctCount - (incorrectCount * 2);
            }

            function calculateTotalCorrectAnswers(availableDirectedIntervals) {
                let totalCorrect = 0;
                availableDirectedIntervals.forEach(directedInterval => {
                    const playedIndex = directedInterval.playedIndex;
                    const correctSemitones = directedInterval.semitones;
                    if (earTrainingStats[playedIndex] && earTrainingStats[playedIndex][correctSemitones] !== undefined) {
                        totalCorrect += earTrainingStats[playedIndex][correctSemitones];
                    }
                });
                return totalCorrect;
            }

            function updateScoreDisplay(availableDirectedIntervals) {
                const totalCorrect = calculateTotalCorrectAnswers(availableDirectedIntervals);
                scoreCounterEl.textContent = totalCorrect;
            }

            function resetStats() {
                localStorage.removeItem(STATS_STORAGE_KEY);
                earTrainingStats = initializeStatsMatrix();
                messageEl.textContent = "Stats Reset! Progress cleared.";
                messageEl.classList.remove('text-green-500', 'text-red-500', 'text-gray-300');
                messageEl.classList.add('text-yellow-500');
                setTimeout(generateQuestion, 500); 
            }
            
            // --- Curriculum Logic ---

            function shouldRestrictToMajorScale() {
                // Filter major scale intervals to only those currently selected by the user
                const activeMajorScaleIntervals = majorScaleDirectedIntervals.filter(
                    interval => userSelectedSemitones.has(interval.semitones)
                );

                for (const directedInterval of activeMajorScaleIntervals) {
                    const score = getCorrectnessScore(directedInterval.playedIndex);
                    if (score < MAJOR_SCALE_CORRECTNESS_THRESHOLD) {
                        return true; 
                    }
                }
                return false; 
            }

            // --- Smart Question Selection Logic ---

            function chooseNextInterval(directedIntervalSet) {
                // If set is empty, handle gracefully (though generateQuestion should prevent this)
                if (!directedIntervalSet || directedIntervalSet.length === 0) return null;

                const intervalData = [];
                let maxScore = -Infinity;
                let totalAttemptsInSet = 0;

                for (const directedInterval of directedIntervalSet) {
                    const playedIndex = directedInterval.playedIndex;
                    let totalAttemptsForInterval = earTrainingStats[playedIndex].reduce((a, b) => a + b, 0);
                    totalAttemptsInSet += totalAttemptsForInterval;
                    let score = getCorrectnessScore(playedIndex);
                    
                    intervalData.push({ directedInterval: directedInterval, score: score });

                    if (score > maxScore) maxScore = score;
                }
                
                if (totalAttemptsInSet === 0) {
                    return directedIntervalSet[getRandomNumber(0, directedIntervalSet.length - 1)];
                }

                let totalWeight = 0;
                intervalData.forEach(data => {
                    data.weight = maxScore - data.score + 1;
                    totalWeight += data.weight;
                });
                
                let randomValue = Math.random() * totalWeight;
                for (const data of intervalData) {
                    randomValue -= data.weight;
                    if (randomValue <= 0) return data.directedInterval;
                }
                return directedIntervalSet[directedIntervalSet.length - 1];
            }

            // --- Audio & Game Logic ---

            async function playInterval() {
                await Tone.start();
                if (!synth) {
                    // Use PolySynth to avoid "Start time" errors during rapid playback
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                }

                messageEl.textContent = "Listen...";
                const startNote = currentStartNote;
                const intervalShift = currentIntervalShift;
                const endNote = Tone.Frequency(startNote).transpose(intervalShift).toNote();

                const now = Tone.now();
                // Schedule notes using Tone's time system + buffer to ensure no past-scheduling
                synth.triggerAttackRelease(startNote, "8n", now + 0.05);
                synth.triggerAttackRelease(endNote, "8n", now + 0.05 + 0.8);
            }

            /**
             * Generates a new ear training question.
             * @param {boolean} autoPlay - If true, play audio immediately. If false, just set up UI.
             */
            function generateQuestion(autoPlay = true) {
                messageEl.textContent = "";
                choicesContainer.innerHTML = "";
                
                // 1. Determine the base pool (Curriculum Logic)
                const restrict = shouldRestrictToMajorScale();
                const baseDirectedPool = restrict ? majorScaleDirectedIntervals : directedIntervals;
                const baseUIPool = restrict ? majorScaleIntervalsUI : intervals;

                // 2. Apply User Selection Filter (Selection Logic)
                // We take the intersection of "Curriculum Allowed" and "User Selected"
                const availableDirectedIntervals = baseDirectedPool.filter(i => userSelectedSemitones.has(i.semitones));
                const availableUIIntervals = baseUIPool.filter(i => userSelectedSemitones.has(i.semitones));
                
                // --- SAFETY CHECK: Ensure we have intervals to play ---
                if (availableDirectedIntervals.length === 0) {
                    messageEl.textContent = "No intervals available! Please select more intervals in settings.";
                    messageEl.className = "text-yellow-500 font-bold";
                    playButton.disabled = true;
                    playButton.classList.add('opacity-50', 'cursor-not-allowed');
                    updateScoreDisplay([]); 
                    return; // STOP HERE
                }

                updateScoreDisplay(availableDirectedIntervals);

                // 3. Select Correct Interval
                currentCorrectInterval = chooseNextInterval(availableDirectedIntervals);
                const correctPlayedIndex = currentCorrectInterval.playedIndex;
                const correctSemitones = currentCorrectInterval.semitones;

                const startMidi = getRandomNumber(STARTING_MIDI_MIN, STARTING_MIDI_MAX);
                currentStartNote = Tone.Midi(startMidi).toNote();
                
                if (correctPlayedIndex === 0) currentIntervalShift = 0;
                else if (correctPlayedIndex <= 12) currentIntervalShift = correctSemitones;
                else currentIntervalShift = -correctSemitones;

                // 4. Weighted selection for Wrong Answers
                // Only pick wrong answers from the AVAILABLE pool (Intersection of Curriculum & User Select)
                const potentialWrongIntervals = availableUIIntervals.filter(interval => interval.semitones !== correctSemitones);

                let weightedWrongChoices = [];
                let totalConfusionWeight = 0;

                potentialWrongIntervals.forEach(interval => {
                    const confusionCount = earTrainingStats[correctPlayedIndex][interval.semitones];
                    const weight = confusionCount + 1; 
                    weightedWrongChoices.push({ interval: interval, weight: weight });
                    totalConfusionWeight += weight;
                });
                
                let selectedWrongAnswers = [];
                let availableWrongChoices = [...weightedWrongChoices]; 
                const wrongAnswerCountToPick = Math.min(WRONG_ANSWER_COUNT, availableWrongChoices.length);

                while (selectedWrongAnswers.length < wrongAnswerCountToPick && availableWrongChoices.length > 0) {
                    let randomValue = Math.random() * totalConfusionWeight;
                    for (let i = 0; i < availableWrongChoices.length; i++) {
                        const choice = availableWrongChoices[i];
                        randomValue -= choice.weight;
                        if (randomValue <= 0) {
                            selectedWrongAnswers.push(choice.interval);
                            totalConfusionWeight -= choice.weight;
                            availableWrongChoices.splice(i, 1);
                            break; 
                        }
                    }
                }

                // 5. Create Buttons
                currentChoices = shuffleArray([
                    availableUIIntervals.find(i => i.semitones === correctSemitones), 
                    ...selectedWrongAnswers
                ]);

                currentChoices.forEach(choice => {
                    const button = document.createElement('button');
                    button.textContent = choice.name;
                    button.classList.add('choice-button', 'bg-gray-700', 'hover:bg-gray-600', 'text-white', 'font-semibold', 'py-3', 'rounded-xl', 'transition', 'duration-200', 'active:scale-95');
                    button.onclick = () => handleAnswer(choice);
                    choicesContainer.appendChild(button);
                });

                playButton.disabled = false;
                playButton.classList.remove('opacity-50', 'cursor-not-allowed');

                // Only autoplay if requested (e.g. not during settings change)
                if (autoPlay) {
                    playInterval();
                } else {
                    messageEl.textContent = "Press 'Play Interval' to hear the new question.";
                    messageEl.className = "text-gray-400 text-sm font-normal";
                }
            }

            function handleAnswer(selectedChoice) {
                const correctPlayedIndex = currentCorrectInterval.playedIndex; 
                const correctSemitones = currentCorrectInterval.semitones;
                const guessedSemitones = selectedChoice.semitones;         
                
                let statsUpdated = false;
                
                if (correctPlayedIndex >= 0 && correctPlayedIndex < STATS_MATRIX_SIZE_PLAYED && 
                    guessedSemitones >= 0 && guessedSemitones < STATS_MATRIX_SIZE_GUESSED) {
                    earTrainingStats[correctPlayedIndex][guessedSemitones]++;
                    statsUpdated = true;
                }

                const allButtons = document.querySelectorAll('.choice-button');
                allButtons.forEach(btn => btn.disabled = true);
                
                if (guessedSemitones === correctSemitones) {
                    messageEl.textContent = "Correct!";
                    messageEl.className = "text-lg font-semibold h-6 text-green-500";
                } else {
                    messageEl.textContent = `Incorrect. The answer was a ${currentCorrectInterval.name}.`;
                    messageEl.className = "text-lg font-semibold h-6 text-red-500";
                }

                if (statsUpdated) saveStats();

                // Update score for the current valid pool
                const restrict = shouldRestrictToMajorScale();
                const baseDirectedPool = restrict ? majorScaleDirectedIntervals : directedIntervals;
                const availableDirectedIntervals = baseDirectedPool.filter(i => userSelectedSemitones.has(i.semitones));
                updateScoreDisplay(availableDirectedIntervals);

                playButton.disabled = true;
                playButton.classList.add('opacity-50', 'cursor-not-allowed');

                setTimeout(() => {
                    generateQuestion();
                }, 2000); 
            }

            // --- Event Listeners and Initialization ---
            
            playButton.addEventListener('click', playInterval);
            resetStatsButton.addEventListener('click', resetStats);
            
            toggleSettingsBtn.addEventListener('click', toggleSettingsPanel);
            selectAllBtn.addEventListener('click', selectAllIntervals);
            selectNoneBtn.addEventListener('click', selectNoneIntervals);

            document.addEventListener('DOMContentLoaded', () => {
                loadStats(); 
                renderIntervalCheckboxes(); // Init settings UI
                generateQuestion(true); // Autoplay on first load
            });

        })();
    </script>
</body>
</html>